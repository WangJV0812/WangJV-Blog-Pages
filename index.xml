<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WangJV Blog</title><link>https://wangjv0812.github.io/WangJV-Blog-Pages/</link><description>Recent content on WangJV Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 06 Aug 2025 16:29:40 +0800</lastBuildDate><atom:link href="https://wangjv0812.github.io/WangJV-Blog-Pages/index.xml" rel="self" type="application/rss+xml"/><item><title>ScoreMatching</title><link>https://wangjv0812.github.io/WangJV-Blog-Pages/2025/08/scorematching/</link><pubDate>Wed, 06 Aug 2025 16:29:40 +0800</pubDate><guid>https://wangjv0812.github.io/WangJV-Blog-Pages/2025/08/scorematching/</guid><description>&lt;ul>
&lt;li>&lt;a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-score-matching">1. 为什么要用 Score Matching&lt;/a>&lt;/li>
&lt;li>&lt;a href="#2-score-function">2. Score Function&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#21-langevin-dynamics">2.1. Langevin Dynamics&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#3-score-matching">3. Score Matching&lt;/a>&lt;/li>
&lt;li>&lt;a href="#4-%E8%AE%A8%E8%AE%BA">4. 讨论&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#41-%E5%93%88%E9%92%A6%E6%A3%AE%E8%BF%B9%E4%BC%B0%E8%AE%A1-hutchinsons-trace-estimation">4.1. 哈钦森迹估计 (Hutchinson&amp;rsquo;s Trace Estimation)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#reference">reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="1-为什么要用-score-matching">1. 为什么要用 Score Matching&lt;/h2>
&lt;p>很多是否，我们希望从大量的数据 $x_1, x_2, \cdots x_n$（或者换句话说，从一个随机变量 $X$ 的大量抽象）还原回分布 $p(x)$ 本身。一个很显然的想法是通过一个带有可优化参数 $\theta$ 的函数 $q(x \mid \theta)$ 来还原/近似真实的数据分布。但是优化过程中，想要保证分布的归一化性质并不容易。一个很显然思路时优化完成后通过归一化系数来保证归一化性质：&lt;/p>
$$
\begin{array}{c}
p(x\mid \theta) = \frac{1}{Z(\theta)}q(x\mid \theta)\\
\text{where: } Z(\theta) = \int q(x\mid \theta) dx
\end{array}
$$&lt;p>但是在很多情况下，生成模型需要处理一个极高维度随机向量的概率分布的积分。此时归一化系数 $Z(\theta)$ 的计算几乎是不可能的。（如果实在希望直接计算，可以用数值方法或者 MCMC，但是这类方法同样很难直接计算。）&lt;/p>
&lt;p>要解决归一化问题的办法其实很多，事实上这在随机分布估计中是一个很常见的问题。我们不妨举一些显然的方案，例如 Flow Module、Bolzemann Machine、Variational Autoencoder 等等。那么如果归一化的分布不好处理，我们是否可以找到一个与归一化的概率分布等价的，不需要归一换的形式？答案是肯定的，就是我们后面要介绍的 Score Function 和对应的估计的方法 Score Matching。&lt;/p></description></item><item><title>Kalman_filter</title><link>https://wangjv0812.github.io/WangJV-Blog-Pages/2024/11/kalman_filter/</link><pubDate>Mon, 04 Nov 2024 16:40:25 +0800</pubDate><guid>https://wangjv0812.github.io/WangJV-Blog-Pages/2024/11/kalman_filter/</guid><description>&lt;ul>
&lt;li>&lt;a href="#1-%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1">1. 最大后验估计&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#11-%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">1.1. 状态估计问题描述&lt;/a>&lt;/li>
&lt;li>&lt;a href="#12-%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1">1.2. 最大后验估计&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#2-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2">2. 卡尔曼滤波&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#21-%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E6%8E%A8%E5%AF%BC-kalman-filter">2.1. 贝叶斯推断推导 kalman filter&lt;/a>&lt;/li>
&lt;li>&lt;a href="#22-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%81%94%E5%90%88%E9%AB%98%E6%96%AF%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E5%88%86%E8%A7%A3%E6%8E%A8%E6%96%AD">2.2. 数学基础：联合高斯概率分布的分解（推断）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#3-extended-kalman-filterekf">3. Extended Kalman Filter（EKF）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#31-%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%BA%BF%E6%80%A7%E5%8C%96%E6%96%B9%E6%B3%95">3.1. 高斯分布的非线性变换（线性化方法）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#32-extended-kalman-filter">3.2. Extended Kalman Filter&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#4-error-state-kalman-filtereskf">4. Error State Kalman Filter（ESKF）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ps: 为了更快的写出来这个文档，我不会很注意公式的粗细体，请见谅。&lt;/p>
&lt;h2 id="1-最大后验估计">1. 最大后验估计&lt;/h2>
&lt;h3 id="11-状态估计问题描述">1.1. 状态估计问题描述&lt;/h3>
&lt;p>我们假设有一个线性系统，其噪声可以用高斯函数来描述。这个线性系统可以如下描述：&lt;/p>
$$
\begin{array}{l}
 x_k = A_{k-1}x_{k-1} + v_k + \omega_k\\
 y_k = Cx_k + n_k
\end{array}
$$&lt;p>其中，有：&lt;/p>
$$
\begin{array}{ll}
 \text{初始噪声} &amp; x_0 \sim \mathcal G (x \mid 0, P_0) \\
 \text{过程噪声} &amp; x_k \sim \mathcal G (x \mid 0, Q_k) \\
 \text{观测噪声} &amp; \omega_k \sim \mathcal G (x \mid 0, R_k)
\end{array}
$$&lt;p>我们认为除了系统的输入 $v_k$ 之外，其余所有变量皆为随机变量。此外我们称 $A_k$ 为状态转移矩阵，$C_k$ 为观测矩阵。对于这个系统而言，系统的初始状态 $x_0$、系统输入 $v_k$ 和 系统输出是已知的。状态估计的目标就是通过这些已知的参数，估计出系统的状态 $x_k$。&lt;/p></description></item><item><title>Mathematics_In_3DGS_1</title><link>https://wangjv0812.github.io/WangJV-Blog-Pages/2024/06/mathematics_in_3dgs_1/</link><pubDate>Sat, 01 Jun 2024 17:13:56 +0800</pubDate><guid>https://wangjv0812.github.io/WangJV-Blog-Pages/2024/06/mathematics_in_3dgs_1/</guid><description>&lt;ul>
&lt;li>&lt;a href="#1-%E4%BD%93%E6%B8%B2%E6%9F%93">1. 体渲染&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#11-%E6%B8%B2%E6%9F%93%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90">1.1. 渲染行为分析&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#111-%E5%90%B8%E6%94%B6">1.1.1 吸收&lt;/a>&lt;/li>
&lt;li>&lt;a href="#112-%E6%94%BE%E5%B0%84">1.1.2. 放射&lt;/a>&lt;/li>
&lt;li>&lt;a href="#113-%E5%A4%96%E6%95%A3%E5%B0%84">1.1.3. 外散射&lt;/a>&lt;/li>
&lt;li>&lt;a href="#114-%E5%86%85%E6%95%A3%E5%B0%84">1.1.4. 内散射&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#12-%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B">1.2. 渲染方程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#2-%E5%BF%AB%E9%80%9F%E5%85%89%E6%A0%85%E5%8C%96">2. 快速光栅化&lt;/a>&lt;/li>
&lt;li>&lt;a href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0">3. 为什么使用高斯函数&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#31-%E9%87%87%E6%A0%B7%E6%B7%B7%E5%8F%A0%E5%92%8C%E6%8A%97%E6%B7%B7%E5%8F%A0">3.1 采样、混叠和抗混叠&lt;/a>&lt;/li>
&lt;li>&lt;a href="#32-%E9%87%8D%E5%BB%BA%E6%A0%B8">3.2 重建核&lt;/a>&lt;/li>
&lt;li>&lt;a href="#33-splatting%E8%BF%87%E7%A8%8B">3.3 Splatting过程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#34-%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%BD%9C%E4%B8%BA%E9%87%8D%E5%BB%BA%E6%A0%B8%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%89%B9%E6%AE%8A%E7%BB%93%E6%9E%84">3.4 高斯分布作为重建核所带来的特殊结构&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E5%8F%82%E8%80%83">参考&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E9%99%84%E5%BD%95">附录&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#a-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">A. 如何解常微分方程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#b-%E6%97%B6%E5%9F%9F%E9%A2%91%E5%9F%9F%E5%8D%B7%E7%A7%AF">B. 时域、频域、卷积&lt;/a>&lt;/li>
&lt;li>&lt;a href="#c-%E5%9C%A8%E9%87%8D%E5%BB%BA%E4%B8%AD%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8%E8%AF%81%E6%98%8E">C. 在重建中高斯分布的重要性质证明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-体渲染">1. 体渲染&lt;/h2>
&lt;p>体渲染的提出时为了解决如云、烟等非刚体的光学行为。可以理解为用于解决对光学&lt;strong>不是完全反射&lt;/strong>，有复杂&lt;strong>透射&lt;/strong>的光学行为。为了对这个光学行为建模，我们将云团（为了叙述方便，我们后面统一将被渲染物体称为云团）视为一团飘忽不定的粒子。光沿直线方向穿过一堆粒子 (粉色部分)，如果能计算出每根光线从最开始发射，到最终打到成像平面上的辐射强度，我们就可以渲染出投影图像。而渲染要做的就是对这个过程进行建模。为了简化计算，我们就假设光子只跟它附近的粒子发生作用，这个范围就是图中圆柱体大小的区间。&lt;/p>
&lt;p>
 &lt;img src="Images/image-20240125001336326.png" alt="Volumn Rendering">

&lt;/p>
&lt;h3 id="11-渲染行为分析">1.1. 渲染行为分析&lt;/h3>
&lt;p>光线与粒子发生发生的作用有如下几类：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>吸收 (absorption)&lt;/strong>：光子被粒子吸收，会导致入射光的辐射强度减弱&lt;/li>
&lt;li>&lt;strong>放射 (emission)&lt;/strong>：粒子本身可能发光，这会进一步增大辐射强度。&lt;/li>
&lt;li>&lt;strong>外散射 (out-scattering)&lt;/strong>：光子在撞击到粒子后，可能会发生弹射，导致方向发生偏移，会减弱入射光强度。&lt;/li>
&lt;li>&lt;strong>内散射 (in-scattering)&lt;/strong>：其他方向的光子在撞到粒子后，可能和当前方向上的光子重合，从而增强当前光路上的辐射强度。&lt;/li>
&lt;/ol>
&lt;p>
 &lt;img src="Images/image-20240125001538229.png" alt="Volumn Rendering">

&lt;/p>
&lt;p>那么对于任意一个云团块而言，出射光与入射光之间的变化量，可以表示为这四个过程的叠加。我们假设入射光线的强度为$I_i$，出射光线为$I_o$，那么有：&lt;/p>
$$
l_o-\mathrm{I}_i= dL(x,\omega) =emission+inscattering-outscatting-absorption
$$&lt;p>
下面针对吸收、发射、内散射、外散射四个环节进行分析。&lt;/p>
&lt;h4 id="111-吸收">1.1.1 吸收&lt;/h4>
&lt;p>我们假设半透明物体中的每个粒子的半径为$r$， 每个粒子的投影面积为$A=$ $\pi r^2$， 并假设圆柱体中粒子的密度为$\rho$，圆柱体的底面积是$E$，并且圆柱体的厚度足够薄。&lt;/p>
&lt;p>
 &lt;img src="Images/image-20240125003153333.png" alt="Volumn Rendering">

&lt;/p>
&lt;p>假定这个厚度是$\Delta s$，那么在这个厚度内，圆柱体体积为$E\Delta s$，粒子总数为$\rho E \Delta s$。这些粒子遮挡的面积为$\rho E \Delta s A$，占整个底面积的比例为$\rho E\Delta sA/E=\rho A\Delta s_{\mathrm{o}}$。也就是说，当一束光通过这个圆柱体的时候，有$\rho A\Delta s$的概率会被遮挡。&lt;/p></description></item></channel></rss>